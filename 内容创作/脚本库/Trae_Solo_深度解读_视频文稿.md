## 开场

你有没有感觉，现在的AI编程工具，正在把你变成一个“工具人”？

东拼西凑，在几个工具来回切换，一会儿是产品经理，一会儿是程序员，一会儿又是测试员...

你以为你在掌控一切，但实际上，你的精力正在被无休-止的上下文切换，消耗得一干二净。

但如果，你的开发过程是这样的呢？

我觉得这个搜索框不好看，直接用鼠标选中它，添加到对话，给我改成圆角。代码就自动改了，浏览器实时刷新，所见即所得。

今天，我们要聊的 Trae Solo 模式，就想让这种“魔法”成为你的日常。它要干掉所有的切换，让你在一个界面里，从一个想法，直接干出一个产品。

但，这到底是AI辅助的终极形态，还是又一个画大饼的“美丽陷阱”？

现在我就带你看看真实的体验是怎么样的？有哪些进步？又有哪些槽点？

## 核心演示

你看Trae官网上写着“SOLO, 你的专属上下文工程师”，听着很玄乎。但我的理解其实很简单：它就是要把我们人类开发者桌面上那一堆东西——代码编辑器、终端、浏览器、需求文档——全都复刻下来，内化到了一个AI身上。

这意味着什么？我们开发者最头疼的“上下文切换”问题，在理论上，被根除了。你再也不用一边开着VSCode，一边开着iTerm，显示器另一侧挂着Chrome浏览器，时不时还要切换到Notion里去看一眼那个该死的需求文档。所有这些信息，都在一个统一的工作空间里流转，AI对你的项目有着“全局视野”。

那这套机制用起来到底怎么样？我们直接用一个实际的项目给它做了一次测试。

### 1. 流程驱动的爽感：从想法到产品的“流水线”

我给它的，是我一直想做的一个真实需求：“一个多端随时随地能够记录想法，收集素材的内容创作辅助工具。”

你看，它并没有立刻开始写代码，而是先生成了一份PRD，然后停下来，把决策权交给我等待确认。这份PRD很简单，包含了产品概览、核心功能、核心流程和UI设计规范。不过我发现，它并没有完全领会我说的“多端”，所以我提醒了它一下，它才把方案调整过来。

点击“确认开发”，它就开始自动安装依赖、搭建项目、生成代码，整个过程就像一个高度自动化的工厂流水线。

前端开发完成后，它还会自动运行代码检查，确保没问题，再自动启动服务，在内置浏览器里让我预览。

当然，这还只是个前端。于是我让它继续开发后端，它就开始写后端逻辑，开发完后也会自动启动服务，然后进行各种检查和测试。

接下来就是更新前端代码，连接后端API。这个环节，它会不断进行代码检查，发现问题就自己修复，循环这个过程，直到检查通过。这确实得益于统一的上下文，让它能及时感知到终端和浏览器的报错。

所以，它这种每个阶段都自带检查测试环节的做法，已经非常像一个成熟的人类程序员了。

整个流程体验下来，我最大的感受，就是它在两个方面取得了巨大的进步：

第一，是流程的自驱动能力。
第二，是无处不在的上下文感知。

### 2. 无缝上下文的丝滑

如果说，刚才的‘流程自驱动’，解决的是从0到1的效率问题。那接下来要展示的‘无缝上下文’，解决的就是从1到100的、反复修改和迭代的体验问题。

比如，它生成的这份PRD，我直接选中这段话，添加到对话，跟他说”我觉得核心功能模块还需要增加MCP服务器，让AI能自动的获取想法。“，它立刻就能在理解文档的基础上，完成有创意的添加。

再看这个UI，我想让这个按钮居中对齐。搁在以前，我得截图、标记、发给前端，或者自己一头扎进代码里去翻组件。但现在呢？你看，我只要点击右上角“选择元素”按钮，然后选中这个按钮，添加到对话，告诉它：“给我居中对齐”。代码马上自动修改，浏览器实时刷新。这种指哪打哪的快感，太上头了。

最让人头疼的Bug来了，控制台一片红。搁在以前，我得复制错误信息，去Google，去Stack Overflow，或者在代码里打断点。现在呢？同样点击“添加到对话”按钮，整个错误堆栈就进来了，告诉它：“报错了”。它不仅读懂了错误信息，还关联了上下文代码，自己开始诊断和修复。我们从焦头烂额的“救火队员”，变成了从容的“现场指挥官”。

更绝的是，这一切修改调试完成后，预览界面右上角，还有一个“部署”按钮，可以直接一键部署。这彻底打通了“最后一公里”。从一个想法，到一个能用的产品原型，整个流程被高度整合，这种一气呵成的体验，确实非常爽。

### 3. 两个绕不开的天花板：“实习生”的上限

好，无论是线性的流程，还是点状的修改，这个流程和体验的优化，确实有爽到。

但就在这个看似完美的流程里，我发现了它两个绕不开的天花板。也正是这两个天花板，暴露了它“通用型实习生”的本质。

第一个，是“规划深度”的天花板，它只能画草图，给不了蓝图。

它生成的PRD，只有产品概览、核心功能、核心流程和UI设计规范这四个部分。这就像一张草图，只能表达一个大概的想法，你根本没法拿着它去指导一个正规团队的协同开发。

而我们自己的PM Agent，输出的是一套完整的“作战蓝图”。它不仅包含Trae Solo那些基础部分，更有详尽的用户研究、市场与竞品分析、细化的非功能性需求、完整的验收标准、以及明确的产品成功指标。

第二个，是“复杂调试”的天花板，它只会“猜”，不会“诊断”。

比如项目开发完，到了最关键的登录环节。它陷入了这个“Fail to fetch”的无限循环里，不断地重启服务、检查代码，把自己绕死了，但就是找不到病根。

后来我实在没办法，只好把它晾在一边，召唤出我们自定义的Debug Agent来救火。和Solo的瞎折腾完全不同，我们的Agent压根没启动什么复杂的诊断流程，仅仅根据我给的报错信息，通过两三轮简单的反馈，就轻松把这个Bug给修复了。

## 升华：揭秘灵魂

所以，刚才那两个看似孤立的问题，背后到底隐藏着什么秘密？

为什么 Solo 生成的PRD就像一张草图？
为什么 Solo 会在同样的地方反复跌倒？

要回答这个问题，我们首先要给 Solo下一个更精准的定义：它其实就是一个官方发布的Agent，

熟悉Trae的朋友，肯定知道之前Trae就内置了两个Agent, 一个是Builder，另一是Builder with MCP，再加上这个就有三个官方Agent了。

这些Agent跟我们自己定义的PM Agent、Debug Agent，本质上是同类。

既然他是Agent，那就好理解了，看过我之前视频的朋友肯定知道，组成一个Agent的关键就是它的Prompt，也就是灵魂，还有就是给他配备了什么工具。

所以Solo的核心就两个：

一个是它掌握的工具，也就是官方宣传的“上下文工程师”，这套工具让它拥有了我们开发者的“桌面环境”，能看、能操作，这是它实现流程自驱动的基础。

另一部分，也是更核心的，就是它的Prompt灵魂，只不过默认官方不让我们看。

Trae Solo之所以强大，又之所以有那些致命的局限，都源于它那个官方写死的“灵魂”。

在PRD规划上，它的灵魂SOP就决定了它只能生成一张“草图”。而我们PM Agent的灵魂，从一开始就是按照我们刚才看到的那套“作战蓝图”的规格来设计的，这才是能打硬仗的专业装备。

在调试这件事上，Trae Solo的灵魂就像一本只会处理皮外伤的“急救手册”。一遇到我们刚才那种前后端状态同步的“内伤”，手册上没写，它就彻底死机、原地打转。而我们的Debug Agent，它的灵魂更像一个经验丰富的外科医生，脑子里装满了处理各种“内伤”的专业知识，所以才能精准定位，药到病除。

而且我发现，Solo只能默认开发Web应用。因为它的“眼睛”，仅仅是那一个内置的浏览器。所以一旦涉及到App或者桌面端，它就彻底变成了“瞎子”。
而我们自己的Agent团队，则是一个全平台军团，覆盖了从Web、App、桌面端，到小程序和浏览器插件的全部战场。

这，就是“通用兵”和“特种兵”的根本区别，

那你是想用一个官方给你配的、啥都会点但啥都不精的“通用兵”，还是想带一支你自己千锤百炼、专打硬仗的“特种兵”？。

## 结论：拥抱“自定义Agent工作流”

所以结论就很清晰了。Trae Solo 给我们指明了一个非常牛逼的方向，就是“上下文驱动的自动化工作流”。但它本身，只是一个起点。

它能让你体验当“监工”的快乐，但真正想让AI为你所用，解决你自己的、独一无二的复杂问题，你必须学会自己去打造、去训练、去指挥你自己的“专家Agent团队”。

这，也正是我在知识星球「威廉的AI Club」里，正在带着大家一起实践和探索的核心命题。我们不只聊这些工具的表面，我们更深入地去探讨，如何把这些工具变成我们自己的武器，如何打造我们自己的AI工作流，甚至是AI团队。

如果你也对拥有自己的“Agent团队”感兴趣，想成为真正的“超级个体”，欢迎你加入我们。

好了，以上就是本期视频想和大家分享的全部内容。希望对你有启发！

分享连接你我，AI点燃心火。期待在星球与你深度连接。

我由衷地相信，这，仅仅是一个开始。

谢谢你的时间，咱们下期再见！ 

